{"meta":{"title":"MEI NET LOG","subtitle":"","description":"","author":"meidongfeng","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2021-08-27T11:35:32.450Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-08-29T11:11:49.000Z","updated":"2021-08-29T11:11:49.062Z","comments":true,"path":"Tags/index.html","permalink":"http://example.com/Tags/index.html","excerpt":"","text":""}],"posts":[{"title":"注解&反射","slug":"注解-反射","date":"2021-09-12T11:01:46.000Z","updated":"2021-09-12T14:53:22.655Z","comments":true,"path":"2021/09/12/注解-反射/","link":"","permalink":"http://example.com/2021/09/12/%E6%B3%A8%E8%A7%A3-%E5%8F%8D%E5%B0%84/","excerpt":"","text":"注解1、概念描述2、作用 编译检查 编写文档 javadoc 命令 代码分析 通过代码里标识的注解对代码进行分析 3、注解分类1.JDK预定义的注解​ @Override： 检查该注解标注的方法是否继承自父类 ​ @Deprecated：废弃的方法 ​ @SupressWarning：告警抑制 2.自定义注解​ 格式： 123456789101112131415元注解public @interface 注解名&#123;&#125;//注解定义public @interface MyAnnotation &#123; String value() ; Person per() default Person.Person1; MyAnnotaion2 annotation();&#125;//注解的使用：@MyAnnotation(value = &quot;100&quot;,annotation = @MyAnnotaion2)public class Woker &#123;&#125; ​ 本质：注解本质上是一个接口，该接口默认继承 Annotation接口 ​ 属性：接口中的方法 ​ 要求： 1、属性的返回值类型： ​ 基本数据类型、 ​ String、 ​ 枚举、 ​ 注解、 ​ 以上类型的数组 ​ 2、定义了属性，使用时需要对属性进行赋值 ​ · 如果定义属性时使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性赋值 ​ · 如果只有一个需要赋值，并且属性名称是value，则value可以省略 ​ · 数组赋值时使用{}，如果数组只有一个值，{}可以省略 ​ 元注解：用于描述注解的注解 ​ 1、@Target描述注解作用位置 ​ 2、@Retention描述注解保留阶段 ​ 3、@Documented描述注解是否被抽取到API文档中 ​ 4、@Inherited：描述注解是否被子类继承 ​ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//@Target 注解，属性为value为Enum类型，表明作用范围@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125;//源码中ElementType 定义作用范围：public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, ... ..。 //@Retent注解@Retention(RetentionPolicy.RUNTIME)public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; ​ 3.解析注解：1234567891011121314151617181920212223242526272829303132@CreateObj(methodName = &quot;show&quot;, className = &quot;com.mei.annotation.Demo1&quot;)public class SaxAnnotationDemo &#123;public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; //1、获取该类字节码文件对象 Class&lt;SaxAnnotationDemo&gt; demoClass = SaxAnnotationDemo.class; //2、获取注解对象 CreateObj createObj = demoClass.getAnnotation(CreateObj.class); //3、调用注解的抽象方法（属性）获取返回值 //在内存中生成了一个该注解接口的子类实现 String className = createObj.className(); String methodName = createObj.methodName(); Class&lt;?&gt; clas = Class.forName(className); //6、创建对象 Constructor&lt;?&gt; constructor = clas.getConstructor(); Object object = constructor.newInstance(); //7、获取对象方法 Method method = clas.getMethod(methodName); //8、调用对象 method.invoke(object); &#125; //注解类：@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface CreateObj &#123; String className(); String methodName();&#125; 反射：框架的设计灵魂反射的概念：将类的各个组成不分封装为其他对象。（反射机制） 反射的优势： 在程序运行中操作这些对象 可以解耦，提高程序可扩展性 1、获取对象的三种方式 1234567891011//获取对象的三种方式： //1、多用于配置文件 Class cls = Class.forName(&quot;com.mei.service.Student&quot;); //2、传参数 Class cls2 = Student.class; //3、通过对象获取字节码文件 Class cls3 = student.getClass(); //同一种字节码文件在一次程序运行中只会被加载一次，不论通过哪种方式获取 System.out.println(cls==cls2);//true System.out.println(cls==cls3);//true 2、Class对象的获取功能1. 获取成员变量1234567891011//获取制定名称的 public修饰的成员变量public Field getField(String name) throws NoSuchFieldException, SecurityException ;//获取所有public修饰的成员变量public Field[] getFields() throws SecurityException ;//获取所有的，设置值前进行权限设置getDeclaredField和getDeclaredFieldsField fieldId=studentClass.getDeclaredField(&quot;id&quot;);fieldId.setAccessible(true); //暴力反射，忽略权限fieldId.set(student,&quot;123456&quot;); 获取到成员变量后可以进行设置值或者取值： 1public void set(Object obj, Object value)//对象，值 2. 获取构造方法123 public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)throws NoSuchMethodException, SecurityException; public Constructor&lt;?&gt;[] getConstructors() throws SecurityException;//Constructor&lt;?&gt;[] contextConstructor= context.getConstructors(); 创建对象： 1public T newInstance(Object ... initargs) 如果使用空参数构造对象，可以使用class对象的newInstance方法 3. 获取成员方法1234 public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException; public Method[] getMethods() throws SecurityException;// 执行方法： invoke； 12345678910//获取构造函数Constructor&lt;Student&gt; constructor = studentClass.getConstructor();//实例化对象 Student student1 = constructor.newInstance();//获取成员方法（方法名，参数类型class） Method method = studentClass.getMethod(&quot;eat&quot;, int.class);//忽略权限 method.setAccessible(true);//调用成员方法，（对象，value） method.invoke(student, 1); 4. 获取类名3、案例：写一个框架，可以创建任意对象12345678910111213141516171819//1、获取类加载器ClassLoader classLoader = Reflect.class.getClassLoader();//2、获取资源文件InputStream resourceAsStream = classLoader.getResourceAsStream(&quot;Object.properties&quot;);//3、加载资源文件Properties properties = new Properties();properties.load(resourceAsStream);//4、读取资源文件内容String className = properties.getProperty(&quot;ClassName&quot;);String methodName = properties.getProperty(&quot;MethodName&quot;);//5、加载类进内存Class&lt;?&gt; clas = Class.forName(className);//6、创建对象Constructor&lt;?&gt; constructor = clas.getConstructor();Object object = constructor.newInstance();//7、获取对象方法Method method = clas.getMethod(methodName);//8、调用对象method.invoke(object);","categories":[],"tags":[{"name":"注解、反射","slug":"注解、反射","permalink":"http://example.com/tags/%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8F%8D%E5%B0%84/"}]},{"title":"spring基于注解的容器配置","slug":"spring02","date":"2021-08-29T07:19:01.000Z","updated":"2021-09-01T13:21:08.364Z","comments":true,"path":"2021/08/29/spring02/","link":"","permalink":"http://example.com/2021/08/29/spring02/","excerpt":"","text":"基于注解的容器配置1、@Required 适用范围：注解适用于 bean 属性 setter 方法 notes： 2、@Autowired 使用范围： 构造函数 setter方法 多个参数的方法 属性 默认情况下，@Autowired 注释意味着依赖是必须的，它类似于 @Required 注释，然而，你可以使用 @Autowired 的 （required=false） 选项关闭默认行为。 3、@Primary 表示当多个 bean 是自动装配到单值依赖项的候选时，应优先考虑特定 bean；作用类似于@Qualifier， 12345678910@Autowired@Qualifier(&quot;main&quot;)// ...@Qualifier还可以在单个构造函数参数或方法参数上指定注释： @Autowired public void prepare(@Qualifier(&quot;main&quot;) MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) &#123; this.movieCatalog = movieCatalog; this.customerPreferenceDao = customerPreferenceDao; &#125; 4、@Qualifier5、@Component","categories":[],"tags":[{"name":"spring","slug":"spring","permalink":"http://example.com/tags/spring/"}]},{"title":"spring","slug":"spring","date":"2021-08-27T11:04:03.000Z","updated":"2021-09-05T09:09:38.888Z","comments":true,"path":"2021/08/27/spring/","link":"","permalink":"http://example.com/2021/08/27/spring/","excerpt":"","text":"Spring-011、Spring扩展 ​ Spring Boot 一个快速开发的手脚架 基于Spring Boot可以快速开发单个微服务 约定大于配置 Spring Cloud 基于Spring Boot 弊端：发展太久，导致配置十分繁琐，配置地狱 2、IOC理论推导原有业务中，用户需求会修改原有代码，如果代码量巨大，成本代价非常昂贵。 之前，程序是主动创建对象，控制权在程序员手上 使用set后，程序不再具有主动性，变成被动接受对象 这种思想从本质上解决了问题，程序员不需要区关注对象的创建，系统耦合性降低，专注于业务实现！这是IOC原型 3、Spring 开始：id相当于变量名， ref：Spring配置好的对象 value：值 4、IOC创建对象默认使用有参构造 有参构造： 构造函数参数解析匹配 123456&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt; &lt;constructor-arg ref=&quot;beanTwo&quot;/&gt; &lt;constructor-arg ref=&quot;beanThree&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;&lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt; 构造函数参数类型匹配： 1234&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt; 构造函数参数索引： 1234&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt; 构造函数参数名称 1234&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt; 5、Spring配置 别名 12&lt;!--别名也可以获取到对象--&gt;&lt;alias name=&quot;xiaoming&quot; alias=&quot;Li Ming&quot;/&gt; Bean的配置 1&lt;bean id=&quot;xiaoming&quot; class=&quot;com.mdong.dao.Student&quot; name=&quot;xioa ming ,LiMing, L&quot; scope=&quot;singleton&quot;&gt; import 导入其他配置文件 6、注入 构造器注入 依赖：bean对象的创建依赖于容器 注入：bean对象的所有属性由容器来注入 set注入 拓展方式注入 Bean的作用域 7、bean的自动装配（spring在上下文中自动寻找，并自动给bean装配属性）使用注解实现自动装配： 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;--!注解的支持 &lt;context:annotation-config/&gt;&lt;/beans&gt; 1、在xml中显示配置​ byname： ​ byType： ​ 12345678910&lt;!-- id就是变量名--&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.mdong.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.mdong.pojo.Dog&quot;/&gt; &lt;!--1、byName，会在容器上下文中查找和set方法后面的值对应的bean--&gt; &lt;!--2、byType，在上下文中查找和对象类型相同的bean--&gt; &lt;bean id=&quot;people&quot; class=&quot;com.mdong.pojo.People&quot; autowire=&quot;byType&quot;&gt;&lt;!-- collaborators and configuration for this bean go here --&gt; 2、在java中显示配置​ 1、@Autowired ​ Autowired默认先按byType，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常。 ​ 可以手动指定按byName方式注入，使用@Qualifier。 1234567891011121314151617//依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; //#注解：@Autowired @Autowired自动装配，通过类型； 属性不唯一，@Qualifier指定名字 public class MovieRecommender&#123; @Autowired @Qualifier(&quot;main&quot;) private MovieCatalog movieCatalog;&#125; 3、隐式的自动装配bean8、使用注解开发在spring4之后，必须导入aop包： 小结：1、注解：12345678910111213自动装配： @Autowired: 自动装配，通过类型名字。手动指定按byName方式注入，使用@Qualifier @Nullable： @Value衍生注解： @Component： @Repository dao层 @Service service层 @Controller controller层 功能一样，将每个类注册到spring，装配bean作用域的注解： @Scope 2、xml注解： xml更加万能，适用于任何场合，维护简单 注解不是自己类使用不了，维护相对复杂 xml与注解最佳实践： xml管理bean 注解负责属性注入 Spring-029、SpringAOP代理模式分类： 1、静态代理 角色分析： 抽象角色：接口或者是抽象类 真实角色：被代理的角色 代理角色：代理真实角色，会有一些附属操作 客户：访问代理对象 优点： 真实角色功能更加纯粹，不需要关注公共业务 公共业务交给代理，实现业务分工 公共业务发生扩展时，方便集中管理 缺点：一个真实角色会产生一个代理角色，代码量增加 2、动态代理： 基于接口的动态代理 JDK动态代理 基于类的动态代理 cglib java字节码，JAVA ssist 3、Spring 实现AOP 方式1：需要实现接口 123456789&lt;!--方式一：--&gt; &lt;bean id=&quot;log&quot; class=&quot;com.mei.service.Log&quot;/&gt; &lt;bean id=&quot;afterLog&quot; class=&quot;com.mei.service.AfterLog&quot;/&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;pointCut&quot; expression=&quot;execution(* com.mei.service.UserServiceImpl.*(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointCut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointCut&quot;/&gt; &lt;/aop:config&gt; 12public class Log implements MethodBeforeAdvice;public class AfterLog implements AfterReturningAdvice ; 方式2：需要配置 123456789101112&lt;!--方式二：--&gt; &lt;bean id=&quot;customLog&quot; class=&quot;com.mei.service.CustomLog&quot;/&gt; &lt;aop:config&gt; &lt;!--自定义切面--&gt; &lt;aop:aspect ref=&quot;customLog&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.mei.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 方式3注解实现： 1234567891011import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class CustomLogTwo &#123; @Before(&quot;execution(* com.mei.service.UserServiceImpl.*(..))&quot;) public void log()&#123; System.out.println(&quot;前置&quot;); &#125;&#125; 配置： 123 proxy-target-class=&quot;true&quot;// 使用cglib，默认false；&lt;bean id=&quot;customLog3&quot; class=&quot;com.mei.service.CustomLogTwo&quot;/&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"JAVA 多线程","slug":"JAVA-Thread","date":"2021-08-15T14:32:17.000Z","updated":"2021-08-15T15:12:29.900Z","comments":true,"path":"2021/08/15/JAVA-Thread/","link":"","permalink":"http://example.com/2021/08/15/JAVA-Thread/","excerpt":"","text":"JAVA1、线程的创建 从Thread派生类，覆写run 创建Thread实例，传入Runnable实例；java8 lambda语法，相当于传入Runnable 通过Callable和Future创建线程 线程池 CompletableFuture： 针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法 1.1各种线程创建方式对比1、采用实现Runnable、Callable接口的方式创建多线程时， 优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 2、使用继承Thread类的方式创建多线程时， 优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。 3、Runnable和Callable的区别 (1) Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。 (2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。 (3) call方法可以抛出异常，run方法不可以。 (4) 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 2、线程状态1、New 2、Runnable 3、Blocked 4、Waiting 5、Timed Waiting 6、Terminated 3、线程同步 4、线程池ExecutorService接口： ​ FixedThreadPool ​ CachedThreadPool ​ SingleThreadExecutor","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"Hello World，Quick Start","slug":"hello-world","date":"2021-08-12T15:24:48.197Z","updated":"2021-08-13T14:07:04.082Z","comments":true,"path":"2021/08/12/hello-world/","link":"","permalink":"http://example.com/2021/08/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"注解、反射","slug":"注解、反射","permalink":"http://example.com/tags/%E6%B3%A8%E8%A7%A3%E3%80%81%E5%8F%8D%E5%B0%84/"},{"name":"spring","slug":"spring","permalink":"http://example.com/tags/spring/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]}