{"meta":{"title":"MEI NET LOG","subtitle":"","description":"","author":"meidongfeng","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2021-08-27T11:35:32.450Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"spring","slug":"spring","date":"2021-08-27T11:04:03.000Z","updated":"2021-08-27T14:48:39.290Z","comments":true,"path":"2021/08/27/spring/","link":"","permalink":"http://example.com/2021/08/27/spring/","excerpt":"","text":"Spring-011、Spring扩展 ​ Spring Boot 一个快速开发的手脚架 基于Spring Boot可以快速开发单个微服务 约定大于配置 Spring Cloud 基于Spring Boot 弊端：发展太久，导致配置十分繁琐，配置地狱 2、IOC理论推导原有业务中，用户需求会修改原有代码，如果代码量巨大，成本代价非常昂贵。 之前，程序是主动创建对象，控制权在程序员手上 使用set后，程序不再具有主动性，变成被动接受对象 这种思想从本质上解决了问题，程序员不需要区关注对象的创建，系统耦合性降低，专注于业务实现！这是IOC原型 3、Spring 开始：id相当于变量名， ref：Spring配置好的对象 value：值 4、IOC创建对象默认使用有参构造 有参构造： 构造函数参数解析匹配 123456&lt;bean id=&quot;beanOne&quot; class=&quot;x.y.ThingOne&quot;&gt; &lt;constructor-arg ref=&quot;beanTwo&quot;/&gt; &lt;constructor-arg ref=&quot;beanThree&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;beanTwo&quot; class=&quot;x.y.ThingTwo&quot;/&gt;&lt;bean id=&quot;beanThree&quot; class=&quot;x.y.ThingThree&quot;/&gt; 构造函数参数类型匹配： 1234&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt; 构造函数参数索引： 1234&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt; 构造函数参数名称 1234&lt;bean id=&quot;exampleBean&quot; class=&quot;examples.ExampleBean&quot;&gt; &lt;constructor-arg name=&quot;years&quot; value=&quot;7500000&quot;/&gt; &lt;constructor-arg name=&quot;ultimateAnswer&quot; value=&quot;42&quot;/&gt;&lt;/bean&gt; 5、Spring配置 别名 12&lt;!--别名也可以获取到对象--&gt;&lt;alias name=&quot;xiaoming&quot; alias=&quot;Li Ming&quot;/&gt; Bean的配置 1&lt;bean id=&quot;xiaoming&quot; class=&quot;com.mdong.dao.Student&quot; name=&quot;xioa ming ,LiMing, L&quot; scope=&quot;singleton&quot;&gt; import 导入其他配置文件 6、注入 构造器注入 依赖：bean对象的创建依赖于容器 注入：bean对象的所有属性由容器来注入 set注入 拓展方式注入 Bean的作用域 7、bean的自动装配（spring在上下文中自动寻找，并自动给bean装配属性）1、在xml中显示配置​ byname： ​ byType： ​ 12345678910&lt;!-- id就是变量名--&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.mdong.pojo.Cat&quot;/&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.mdong.pojo.Dog&quot;/&gt; &lt;!--1、byName，会在容器上下文中查找和set方法后面的值对应的bean--&gt; &lt;!--2、byType，在上下文中查找和对象类型相同的bean--&gt; &lt;bean id=&quot;people&quot; class=&quot;com.mdong.pojo.People&quot; autowire=&quot;byType&quot;&gt;&lt;!-- collaborators and configuration for this bean go here --&gt; 2、在java中显示配置​ 1、@Autowired ​ Autowired默认先按byType，如果发现找到多个bean，则，又按照byName方式比对，如果还有多个，则报出异常。 ​ 可以手动指定按byName方式注入，使用@Qualifier。 1234567891011121314151617//依赖： &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; //#注解：@Autowired @Autowired自动装配，通过类型； 属性不唯一，@Qualifier指定名字 public class MovieRecommender &#123; @Autowired @Qualifier(&quot;main&quot;) private MovieCatalog movieCatalog;&#125; 3、隐式的自动装配bean","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"JAVA 多线程","slug":"JAVA-Thread","date":"2021-08-15T14:32:17.000Z","updated":"2021-08-15T15:12:29.900Z","comments":true,"path":"2021/08/15/JAVA-Thread/","link":"","permalink":"http://example.com/2021/08/15/JAVA-Thread/","excerpt":"","text":"JAVA1、线程的创建 从Thread派生类，覆写run 创建Thread实例，传入Runnable实例；java8 lambda语法，相当于传入Runnable 通过Callable和Future创建线程 线程池 CompletableFuture： 针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法 1.1各种线程创建方式对比1、采用实现Runnable、Callable接口的方式创建多线程时， 优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 2、使用继承Thread类的方式创建多线程时， 优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。 3、Runnable和Callable的区别 (1) Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。 (2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。 (3) call方法可以抛出异常，run方法不可以。 (4) 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。 2、线程状态1、New 2、Runnable 3、Blocked 4、Waiting 5、Timed Waiting 6、Terminated 3、线程同步 4、线程池ExecutorService接口： ​ FixedThreadPool ​ CachedThreadPool ​ SingleThreadExecutor","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"Hello World，Quick Start","slug":"hello-world","date":"2021-08-12T15:24:48.197Z","updated":"2021-08-13T14:07:04.082Z","comments":true,"path":"2021/08/12/hello-world/","link":"","permalink":"http://example.com/2021/08/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]}